package replicatedserverport.rpc.duplex.singleresponse;

import inputport.datacomm.SendTrapper;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import port.trace.AsyncReplayEndInfo;
import port.trace.ConnectedToSessionServer;
import port.trace.ReplayStartInfo;
import sessionport.datacomm.duplex.object.relayed.MessageWithSource;
import util.trace.TraceableBus;
import util.trace.Tracer;


public class ASingleResponseClientMessagesManager implements ClientMessagesManager{
	public static int MAX_SERVER_BUFFERED_MESSAGES = 100;
	protected List<String> servers = new ArrayList();	
	protected String currentServer;
	protected int messagesReceived;
	protected int messagesReceivedSinceLastControlMessage;
	protected SendTrapper<Object, Object> sendTrapper;
	boolean replayMode;
	String sessionServerName;
	// called by receive trapper to send control messages
	public ASingleResponseClientMessagesManager() {
		TraceableBus.addTraceableListener(this);
//		Tracer.setKeywordPrintStatus(this, true);

		
	}
	public SendTrapper<Object, Object> getSendTrapper() {
		return sendTrapper;
	}
	public void setSendTrapper (SendTrapper<Object, Object> newVal) {
		sendTrapper = newVal;
	}
	public String getCurrentServer() {
		return currentServer;
	}
	//called by client send trapper
	public boolean addServer(String server) {
		servers.add(server);
		return setNewServer();
	}
	//called by client send trapper
	public boolean removeServer(String server) {
		servers.remove(server);
		return setNewServer();
	}
	public void receivedNewMessage(String aRemoteEnd, Object aMessage) {
		if (currentServer == null || 
				// replay mode messages were not actually generated by any server so do not want to tell server you have received them
				// upstream client message manager does not have to worry about replay mode
				// only the one after the latecomer port,
				// replay mode implies there is a downstream one
				// which means upstream one must be gettng message with source
				// except that the session manager can send its own messags
//				((aMessage instanceof MessageWithSource) && replayMode))
				// session server messages, even in replay mode are to marked
				((!(aRemoteEnd.equals(sessionServerName)) && replayMode))) 

				
		{ 
			Tracer.info(this, "Not recording replay mesage:" + aMessage + " from:" + aRemoteEnd );
			return; // this is a late message  from a session server.
		}
		messagesReceived++;
		messagesReceivedSinceLastControlMessage++;
		Tracer.info(this, "messages received:" + messagesReceived + "messagesReceivedSinceLastControlMessage " + 
		messagesReceivedSinceLastControlMessage);
	}
	public int getReceivedMessages() {
		return messagesReceived;
	}
	public boolean sendUpdateControlMessage() {
		return messagesReceivedSinceLastControlMessage >= MAX_SERVER_BUFFERED_MESSAGES;
	}
	public void controlMessageSent() {
		messagesReceivedSinceLastControlMessage = 0;
	}
	
	// can be made an abstract method in an abstract class
	protected boolean setNewServer() {
		if (servers.size() == 0) {
			Tracer.error("Lost connection to all servers");
			currentServer = null;
			return false;
		}
		String oldServer = currentServer;	
		Collections.sort(servers);
		currentServer = servers.get(0);
		return !currentServer.equals(oldServer);
	}
	@Override
	public void newEvent(Exception aTraceable) {
		if (aTraceable instanceof ReplayStartInfo ) { // event generated and consumed
			Tracer.info(this, "Enter replay mode");
			replayMode = true;
		} 
		else if (aTraceable instanceof AsyncReplayEndInfo) { // do not need to know about sync as we need to simply know all messages have been received
	
			replayMode = false;


		} else if (aTraceable instanceof ConnectedToSessionServer) {
			ConnectedToSessionServer connectedToSessionServer = (ConnectedToSessionServer) aTraceable;
			sessionServerName = connectedToSessionServer.getSessionServerName();
		}
	}
}
